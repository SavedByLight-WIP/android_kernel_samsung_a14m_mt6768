name: Build Samsung MTK Kernel (6.6 Kleaf/Bazel)

on:
  workflow_dispatch:
    inputs:
      product:
        description: "Android product name under out/target/product (e.g. a14m)"
        required: true
        default: "a14m"
      project:
        description: "Kleaf project prefix (must match Bazel targets, e.g. mgk_64_k66 or your new one)"
        required: true
        default: "mgk_64_k66"
      mode:
        description: "Build mode suffix used by Kleaf targets (commonly: user)"
        required: true
        default: "user"
      defconfig:
        description: "Kernel defconfig for gen_build_config.py"
        required: true
        default: "mediatek-bazel_defconfig"
      defconfig_overlays:
        description: "Space-separated defconfig overlays (e.g. 'mt6768_overlay.config o22.config')"
        required: false
        default: "mt6768_overlay.config o22.config"
      target:
        description: "Optional: override TARGET (without .<mode> suffix). Leave empty for default *_modules_install."
        required: false
        default: ""

jobs:
  build-kernel:
    runs-on: ubuntu-latest
    env:
      # (Kept for compatibility with older node in container)
      ACTIONS_ALLOW_USE_UNSECURE_NODE_VERSION: true

    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install build dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          DEBIAN_FRONTEND=noninteractive sudo apt-get install -y bash coreutils findutils gawk sed grep git ca-certificates curl wget python3 python3-setuptools rsync unzip zip xz-utils file bc bison flex build-essential clang llvm lld libssl-dev libelf-dev libncurses5-dev openjdk-17-jdk-headless

      - name: Install Bazelisk
        shell: bash
        run: |
          set -euo pipefail
          PIN="6.4.0"
          sudo curl -L https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 \
            -o /usr/local/bin/bazel
          sudo chmod +x /usr/local/bin/bazel
          
          # Pin Bazelisk selection even without .bazelversion
          echo "USE_BAZEL_VERSION=${PIN}" >> "${GITHUB_ENV}"
          echo "BAZELISK_VERSION=${PIN}" >> "${GITHUB_ENV}"
    
          bazel --version
          ROOT="${GITHUB_WORKSPACE}/kernel"
          BAZEL_HERM="${ROOT}/prebuilts/kernel-build-tools/bazel/linux-x86_64"
          mkdir -p "${BAZEL_HERM}"
          ln -sf /usr/local/bin/bazel "${BAZEL_HERM}/bazel"
          ls -la "${BAZEL_HERM}"

      - name: Show environment
        shell: bash
        run: |
          set -euo pipefail
          echo "Runner: $(uname -a)"
          python3 --version
          javac -version || true
          
      - name: Provide Kleaf hermetic build-tools shims
        shell: bash
        run: |
          set -euo pipefail

          # Some Samsung/Kleaf trees expect hermetic build-tools under:
          #   kernel/prebuilts/build-tools/path/linux-x86/
          # OSS drops sometimes omit these prebuilts. We'll create minimal shims
          # by symlinking any *referenced* hermetic tools to runner equivalents.
          ROOT="${GITHUB_WORKSPACE}/kernel"
          HERM="${ROOT}/prebuilts/build-tools/path/linux-x86"
          mkdir -p "${HERM}"

          # Gather tool names referenced by scripts (best-effort).
          mapfile -t TOOLS < <(
            grep -RohE 'prebuilts/build-tools/path/linux-x86/[A-Za-z0-9_.+-]+'               "${ROOT}/tools/bazel"               "${ROOT}/kernel_device_modules-6.6/kernel/kleaf/_setup_env.sh"               "${ROOT}/kernel_device_modules-6.6/build.sh"               2>/dev/null             | sed 's#.*/linux-x86/##'             | sort -u
          )

          # Ensure at least python3 is present.
          if ! printf '%s' "${TOOLS[@]}" | grep -qx 'python3'; then
            TOOLS+=("python3")
          fi

          echo "Hermetic tool references detected: ${TOOLS[*]}"

          for t in "${TOOLS[@]}"; do
            dest="${HERM}/${t}"
            [ -e "${dest}" ] && continue

            if command -v "${t}" >/dev/null 2>&1; then
              ln -sf "$(command -v "${t}")" "${dest}"
              continue
            fi

            case "${t}" in
              python) command -v python3 >/dev/null 2>&1 && ln -sf "$(command -v python3)" "${dest}" ;;
              sh)     command -v bash    >/dev/null 2>&1 && ln -sf "$(command -v bash)"    "${dest}" ;;
              *)      echo "WARN: host tool not found for hermetic '${t}' (left missing)" ;;
            esac
          done

          ls -la "${HERM}" || true
          "${HERM}/python3" --version

      - name: Restore required AOSP prebuilts (fast, shallow)
        shell: bash
        run: |
          set -euo pipefail

          # 1) platform/prebuilts/build-tools   -> kernel/prebuilts/build-tools
          # 2) kernel/prebuilts/build-tools     -> kernel/prebuilts/kernel-build-tools
          #
          # For clang host prebuilts, cloning the full toolchain is huge; we only pull
          # kernel/prebuilts/clang/host/linux-x86/kleaf (Starlark support files).

          KROOT="${GITHUB_WORKSPACE}/kernel"
          mkdir -p "${KROOT}/prebuilts"

          # platform/prebuilts/build-tools (GitHub mirror is usually faster from Actions)
          if [ ! -d "${KROOT}/prebuilts/build-tools" ]; then
            git clone --depth=1 https://github.com/msft-mirror-aosp/platform.prebuilts.build-tools "${KROOT}/prebuilts/build-tools"
          fi

          # kernel/prebuilts/build-tools checked out into prebuilts/kernel-build-tools
          if [ ! -d "${KROOT}/prebuilts/kernel-build-tools" ]; then
            git clone --depth=1 https://android.googlesource.com/kernel/prebuilts/build-tools "${KROOT}/prebuilts/kernel-build-tools"
          fi

          # Many Samsung/Kleaf WORKSPACE setups expect local repositories under:
          #   kernel/external/<name>
          # but in OSS drops these are often SYMLINKS to:
          #   ../../external/<name>  (repo root external/)
          #
          # So we hydrate the repo-root external/ directory, which satisfies both:
          #   - direct paths: ${KROOT}/external/<name> (if real dirs)
          #   - symlinked paths: ${KROOT}/external/<name> -> ../../external/<name>

          EXT_ROOT="${GITHUB_WORKSPACE}/external"
          mkdir -p "${EXT_ROOT}"

          clone_shallow() {
            local url="$1"
            local dest="$2"
            if [ -e "${dest}/.git" ]; then
              return 0
            fi
            rm -rf "${dest}" 2>/dev/null || true
            git clone --depth=1 "${url}" "${dest}"
          }

          # Helper: ensure a repo exists at the path referenced by kernel/external/<name>.
          ensure_external_repo() {
            local name="$1" url="$2"
            local kpath="${KROOT}/external/${name}"

            # If kernel/external/<name> is a symlink, hydrate its resolved target.
            if [ -L "${kpath}" ]; then
              local target
              target="$(readlink -f "${kpath}")"
              mkdir -p "$(dirname "${target}")"
              clone_shallow "${url}" "${target}"
              return 0
            fi

            # If kernel/external/<name> is a real directory, clone directly into it.
            if [ -d "${kpath}" ]; then
              # If it's empty-ish and not a git repo, populate it.
              if [ ! -d "${kpath}/.git" ]; then
                rm -rf "${kpath}"
                clone_shallow "${url}" "${kpath}"
              fi
              return 0
            fi

            # If it doesn't exist, create it as a symlink to repo-root external/<name> and hydrate there.
            mkdir -p "${KROOT}/external"
            if [ ! -e "${kpath}" ]; then
              ln -s "../../external/${name}" "${kpath}"
            fi
            clone_shallow "${url}" "${EXT_ROOT}/${name}"
          }

          # Required externals (as per your symlink layout)
          ensure_external_repo "bazel-skylib"              "https://android.googlesource.com/platform/external/bazel-skylib"
          ensure_external_repo "bazelbuild-rules_cc"       "https://github.com/bazelbuild/rules_cc.git"
          ensure_external_repo "bazelbuild-rules_license"  "https://github.com/bazelbuild/rules_license.git"
          ensure_external_repo "bazelbuild-rules_pkg"      "https://github.com/bazelbuild/rules_pkg.git"
          ensure_external_repo "bazelbuild-rules_python"   "https://github.com/bazelbuild/rules_python.git"
          ensure_external_repo "bazelbuild-rules_rust"     "https://github.com/bazelbuild/rules_rust.git"
          ensure_external_repo "libcap"                    "https://android.googlesource.com/platform/external/libcap"
          ensure_external_repo "libcap-ng"                 "https://android.googlesource.com/platform/external/libcap-ng"
          ensure_external_repo "stardoc"                   "https://github.com/bazelbuild/stardoc.git"
          
          # Ensure Bazel package markers exist for the clang kleaf directory (and parents).
          # Some OSS exports omit these BUILD files; Bazel requires them for labels like:
          #   //prebuilts/clang/host/linux-x86/kleaf:clang_toolchain_repository.bzl
          ensure_build_marker() {
            local p="$1"
            if [ -L "${p}" ]; then
              p="$(readlink -f "${p}")"
            fi
            mkdir -p "${p}"
            : > "${p}/BUILD.bazel"
          }

          ensure_build_marker "${KROOT}/prebuilts/clang"
          ensure_build_marker "${KROOT}/prebuilts/clang/host"
          ensure_build_marker "${KROOT}/prebuilts/clang/host/linux-x86"
          ensure_build_marker "${KROOT}/prebuilts/clang/host/linux-x86/kleaf"

          echo "clang kleaf package marker:"
          ls -la "${KROOT}/prebuilts/clang/host/linux-x86/kleaf" | head -n 20

      - name: Generate build.config
        shell: bash
        run: |
          set -euo pipefail

          PRODUCT="${{ inputs.product }}"
          DEFCONFIG="${{ inputs.defconfig }}"
          OVERLAYS="${{ inputs.defconfig_overlays }}"

          # Paths are RELATIVE to the 'kernel/' directory because _setup_env.sh
          # expects BUILD_CONFIG (and often OUT_DIR) to be relative to ROOT_DIR.
          KERNEL_OBJ_REL="../out/target/product/${PRODUCT}/obj/KERNEL_OBJ"
          mkdir -p "${KERNEL_OBJ_REL}"

          cd kernel

          python3 kernel_device_modules-6.6/scripts/gen_build_config.py             --kernel-defconfig "${DEFCONFIG}"             --kernel-defconfig-overlays "${OVERLAYS}"             --kernel-build-config-overlays ""             -m "${{ inputs.mode }}"             -o "${KERNEL_OBJ_REL}/build.config"

          echo "PRODUCT=${PRODUCT}" >> "${GITHUB_ENV}"
          echo "DEFCONFIG=${DEFCONFIG}" >> "${GITHUB_ENV}"
          echo "DEFCONFIG_OVERLAYS=${OVERLAYS}" >> "${GITHUB_ENV}"
          echo "BUILD_CONFIG=${KERNEL_OBJ_REL}/build.config" >> "${GITHUB_ENV}"

          echo "=== build.config (head) ==="
          head -n 80 "${KERNEL_OBJ_REL}/build.config" || true
          echo "==========================="


      - name: Build kernel + modules (Kleaf/Bazel)
        shell: bash
        run: |
          set -euo pipefail

          PROJECT="${{ inputs.project }}"
          MODE="${{ inputs.mode }}"
          TARGET_INPUT="${{ inputs.target }}"

          export PROJECT MODE

          # Keep these RELATIVE to kernel/ for Kleaf env scripts.
          export OUT_DIR="../out/target/product/${PRODUCT}/obj/KLEAF_OBJ"
          export DIST_DIR="${OUT_DIR}/dist"
          export BUILD_CONFIG="${BUILD_CONFIG}"

          mkdir -p "${OUT_DIR}" "${DIST_DIR}"

          if [ -n "${TARGET_INPUT}" ]; then
            export TARGET="${TARGET_INPUT}"
          fi

          cd kernel

          # Uses tools/bazel from the tree and Kleaf rules.
          ./kernel_device_modules-6.6/build.sh

          echo "DIST_DIR=${DIST_DIR}" >> "${GITHUB_ENV}"

      - name: Collect artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts

          # DIST_DIR is relative to kernel/ in this workflow.
          DIST_ABS="${GITHUB_WORKSPACE}/kernel/${DIST_DIR}"

          if [ -d "${DIST_ABS}" ]; then
            cp -av "${DIST_ABS}" "artifacts/dist"
          else
            echo "ERROR: dist not found: ${DIST_ABS}"
            echo "Listing ${GITHUB_WORKSPACE}/kernel/../out (if present):"
            ls -la "${GITHUB_WORKSPACE}/out/target/product/${PRODUCT}/obj" || true
            exit 1
          fi

          # Also store the generated build.config for debugging
          BC_ABS="${GITHUB_WORKSPACE}/kernel/${BUILD_CONFIG}"
          if [ -f "${BC_ABS}" ]; then
            cp -v "${BC_ABS}" artifacts/
          fi


      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: "${{ inputs.product }}-kernel-6.6-kleaf"
          path: artifacts
